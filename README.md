# COP3000

—— 计算机组成原理课程设计辅助程序



## 设计目的

用于自动化生成计组课设报告中的以下部分：

+ 指令集表

+ 微指令集表

+ 程序执行跟踪结果

+ 由CSV生成指令系统INS文件

以上部分也许是为了存档或检验课程设计原创性，要求将COP2000模拟器上的结果抄到word表格中，显然这会花费巨量的时间且对学生意义甚微。在设计指令系统环节，更是照着原指令系统打勾打到麻木。作为计算机系的学生，我们生来具有改变落后生产技术、以自动化替代人工重复工作的义务。这也是本项目的最初设计动机。

同时，本项目的核心是一个微指令级别的虚拟机，对于理解开发板的某些逻辑也许有帮助。

本项目已通过数个乘除法程序测试，与COP2000软件模拟结果未发现区别。



## 使用方法

+ 生成指令集表/微指令集表

  ```python
  # 会询问文件的路径
  python run.py
  # 直接进行解析
  python run.py 文件名
  ```

+ 生成程序执行跟踪结果

  先打开simulation.py，在开头处修改模拟参数：

  ```
  ins_path：可通过COP2000"保存指令系统"导出
  
  bin_path：等效于"EM程序"的二进制文件，共256字节；通过COP2000"汇编"生成，如果需要在EM区域内预先写入数据，则在COP2000的"EM程序"标签下写入，再汇编保存即可。
  
  lst_path：标记了ASM文件中每条指令的位置，可通过汇编生成。用于获取未经汇编处理的原始指令。
  
  trace_path：自动生成的跟踪文件

  simulation_times：模拟的微指令周期数，即模拟多少次"单微指令执行"。
  
  ins2description函数：指令的解释。你可以对其自由修改，以自动生成指令解释。
  ```

  保存后执行即可。

  ```
  python simulation.py
  ```

  部分输出如下：

  <img src="assets\img1.jpg" alt="img1"  />

  circle：微指令周期数	pc：当前pc值	ins：当前执行指令

  upc：当前upc值/当前微指令

  got next instruction：触发IR新指令载入，显示下一条指令

  <img src="assets\img2.jpg" alt="img2"  />

  模拟完成时，输出当前EM数据矩阵，可用于检验正确性。

+ 由CSV文件生成指令系统INS文件
  
  ***powered by @Chardo-v***
  
  在table2ins文件夹下，提供了一个COP2000自带指令集文件ins_table.csv，文件里面包含了每条指令的地址和四条微指令。
  
  你可以随意对指令表进行添加、删除、调换顺序、换名等操作。但有两点需要注意：
  
  > - 不允许对`_FETCH_`和`_INT_`两条指令的位置和微指令有任何修改。
  > 
  > - 可以对JC、JZ、JMP指令进行位置上的调整，但需要注意三条指令的微地址高四位必须相同，低四位分别是0x0H、0x4H、0x0CH。

  运行`table2ins.py`，即可生成指令系统INS文件。


## 参考项目

本项目的父项目为 https://github.com/WqVoon/parse_cop2000_ins_to_table ，在此基础上继续开发，补充和完善了一些功能



## 工作原理

COP2000可以将指令集、微指令集写入后缀.INS的文件中，同时编译时会生成后缀为.BIN的文件（与EM程序完全相同）,和LST文件（含有汇编指令与EM中数据位置的映射，可以省去汇编过程）。通过解析指令集和EM程序的方式，我们可以略过编译阶段，用较简单的方式完成模拟。

指令集表和微指令集表可以直接通过读取INS文件直接获得（详见参考项目）；运行跟踪结果由一个微指令级的虚拟机模拟得到。通过对INS文件的一点点逆向工程研究，即可由指令和微指令配置生成INS文件。
